//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
	"text/template"
)

type MessageInfo struct {
	Name     string
	Type     string
	ID       uint32
	EnumName string
	Package  string
}

type TemplateData struct {
	Messages []MessageInfo
	Imports  []string
}

const templateText = `
// Code generated by protoc-gen-msgtype. DO NOT EDIT.
package msgtype

import (
    "reflect"
    "sort"
    "strings"
    "sync"
    {{range .Imports}}
    "{{.}}"
    {{end}}
)

type MessageTypeInfo struct {
    MsgType     uint32          
    RequestType reflect.Type
    ReplyType   reflect.Type
    Name        string
}

type MessageRegistry struct {
    mu           sync.RWMutex
    messageTypes map[reflect.Type]uint32    
    messageInfos map[uint32]*MessageTypeInfo 
}

var defaultRegistry = NewMessageRegistry()

func NewMessageRegistry() *MessageRegistry {
    r := &MessageRegistry{
        messageTypes: make(map[reflect.Type]uint32),    
        messageInfos: make(map[uint32]*MessageTypeInfo), 
    }
    r.init()
    return r
}

func (r *MessageRegistry) init() {
    {{range .Messages}}
    r.registerMessage(
        {{.Package}}.{{.Type}},
        uint32({{.Package}}.{{.EnumName}}_{{.Name}}),  
        "{{.Name}}",
    )
    {{end}}
}

func (r *MessageRegistry) registerMessage(msg interface{}, msgType uint32, name string) {  
    msgTyp := reflect.TypeOf(msg)
    
    info := &MessageTypeInfo{
        MsgType: msgType,
        Name:    name,
    }
    
    if strings.HasSuffix(name, "REQ") {
        info.RequestType = msgTyp
    } else if strings.HasSuffix(name, "RSP") {
        info.ReplyType = msgTyp
    }
    
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.messageTypes[msgTyp] = msgType
    r.messageInfos[msgType] = info
}

func GetMessageType(msg interface{}) uint32 {  
    if msg == nil {
        return 0
    }
    
    defaultRegistry.mu.RLock()
    defer defaultRegistry.mu.RUnlock()
    
    msgType := reflect.TypeOf(msg)
    if msgType.Kind() == reflect.Ptr {
        msgType = msgType.Elem()
    }
    
    if msgType, ok := defaultRegistry.messageTypes[msgType]; ok {
        return msgType
    }
    return 0
}

func GetMessageInfo(msgType uint32) *MessageTypeInfo {  
    defaultRegistry.mu.RLock()
    defer defaultRegistry.mu.RUnlock()
    
    return defaultRegistry.messageInfos[msgType]
}

func GetAllMessageTypes() []uint32 {  
    defaultRegistry.mu.RLock()
    defer defaultRegistry.mu.RUnlock()
    
    var types []uint32  
    for msgType := range defaultRegistry.messageInfos {
        types = append(types, msgType)
    }
    
    sort.Slice(types, func(i, j int) bool {
        return types[i] < types[j]
    })
    
    return types
}
`

func main() {
	opts := protogen.Options{
		ParamFunc: func(name, value string) error {
			return nil
		},
	}

	opts.Run(func(gen *protogen.Plugin) error {
		var allMessages []MessageInfo
		var imports []string

		// 遍历所有文件收集消息
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			messages, imp := collectMessages(f)
			allMessages = append(allMessages, messages...)
			if imp != "" {
				imports = append(imports, imp)
			}
		}

		if len(allMessages) == 0 {
			return nil
		}

		// 生成单个文件
		return generateSingleFile(gen, allMessages, imports)
	})
}

func toStructName(name string) string {
	// 移除 MSG_TYPE_ 前缀，并转换为驼峰命名
	//name = strings.TrimPrefix(name, "MSG_TYPE_")
	parts := strings.Split(name, "_")
	var result string
	for _, part := range parts {
		if part == "REQ" {
			continue
		}
		if part == "RSP" {
			continue
		}
		result += cases.Title(language.Und).String(part)
	}
	return result
}

func collectMessages(file *protogen.File) ([]MessageInfo, string) {
	messages := make([]MessageInfo, 0)

	for _, enum := range file.Enums {
		if strings.HasSuffix(string(enum.Desc.Name()), "MsgType") {
			enumName := string(enum.Desc.Name())
			for _, v := range enum.Values {
				if v.Desc.Name() != "MSG_TYPE_UNKNOWN" {
					messages = append(messages, MessageInfo{
						Name:     string(v.Desc.Name()),
						ID:       uint32(v.Desc.Number()),
						EnumName: enumName,
						Package:  string(file.GoPackageName),
					})
				}
			}
		}
	}

	// 修改类型名称生成方式
	for i := range messages {
		name := messages[i].Name
		structName := toStructName(name)
		if strings.HasSuffix(name, "REQ") {
			messages[i].Type = fmt.Sprintf("%sRequest{}", structName)
		} else if strings.HasSuffix(name, "RSP") {
			messages[i].Type = fmt.Sprintf("%sResponse{}", structName)
		}
	}

	var importPath string
	if len(messages) > 0 {
		// 使用相对路径
		importPath = fmt.Sprintf("mineNet/proto/%s", file.GoPackageName)
	}

	return messages, importPath
}

func generateSingleFile(gen *protogen.Plugin, messages []MessageInfo, imports []string) error {
	data := TemplateData{
		Messages: messages,
		Imports:  imports,
	}

	filename := "msg-type.go"
	g := gen.NewGeneratedFile(filename, "")

	var buf bytes.Buffer
	tmpl := template.Must(template.New("msg_registry").Parse(templateText))
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execution failed: %v", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("code formatting failed: %v", err)
	}

	_, err = g.Write(formatted)
	if err != nil {
		return fmt.Errorf("failed to write generated code: %v", err)
	}

	return nil
}
